---
title: 深入理解JVM(2)--垃圾回收算法
date: 2018-09-03 16:15:10
tags: [JVM]
categories: [JVM]
---
# 垃圾回收算法

## 标记-清除算法（Mark-Sweep）
算法分为”标记“和”清除“两个阶段：

1. 遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象
2. 遍历堆中所有的对象，将没有标记的对象全部清除掉

**优点**：

1. 可以解决循环引用问题
2. 必要时才回收（内存不足时）

**缺点**：

1. 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
2. 效率问题，因为内存碎片的存在，操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单的操作

![](https://pic3.zhimg.com/80/v2-739c5ce4462a56a4b206729776199805_hd.jpg)

## 复制算法（Copying）
将可用内存容量划分为大小相等店小二两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过得内存空间一次清理掉。这样使用每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。

**优点**:

1. 吞吐量大，只需要遍历一次From空间Sweep需要遍历两次，而且只复制存活的对象
2. 高速分配，不需要通过空闲链表直接在连续的内存上进行分配
3. 没有碎片
4. 与缓存兼容，复制存活对象时采用深度优先算法使相关联的对象都在附近

**缺点**：

1. 堆的使用率低，必须分配一个To，其不能分配对象
2. 不兼容保守式GC算法（会错误的认为不能识别的对象为存活对象，造成垃圾对象留在堆中），需要移动对象
3. 递归调用，复制对象的深度优先算法是通过递归调用实现的，递归将消耗栈等资源

![](https://pic4.zhimg.com/80/v2-8db8c2a886bd11d90ded549dec7500e3_hd.jpg)

## 标记-整理算法（Mark-Compack）
该算法可以说是在标记-清除算法的基础的升级。

1. 遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象
2. 标记完成后，将所有存活的对象都向一端移动
3. 清除掉端边界以外的内存

**优点**：

1. 堆利用效率高
2. 无碎片

**缺点**:
1. 相较标记-清除算法，效率变低，多了一步整理内存碎片的过程

![](https://pic4.zhimg.com/80/v2-c4351de7d8c14631a66a6571b05d102f_hd.jpg)

## 分代收集算法
将java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

* 新生代 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
* 老年代 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或“标记-整理”算法来进行回收。

**优点**：

1. 可以根据各个年代的特点采用最适合的收集算法

**缺点**：

1. 不能控制每次垃圾收集的时间