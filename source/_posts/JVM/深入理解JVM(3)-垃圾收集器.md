---
title: 深入理解JVM(3)--垃圾收集器
date: 2018-09-04 16:15:10
tags: [JVM]
categories: [JVM]
---
接下来讨论的收集器基于JDK1.7 Update 14 之后的HotSpot虚拟机（在此版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），该虚拟机包含的所有收集器如下图所示：
![](https://pic.yupoo.com/crowhawk/56a02e55/3b3c42d2.jpg)

图中连线说明 两种垃圾收集器可以配置使用。
例如：

Serial/CMS,Serial/Serial Old,ParNew/CMS,ParNew/Serial Old等

CMS/Serial Old这种老年代组合的意思是指 Serial Old作为CMS的备选收集器使用，当CMS发生异常的时候，Serial Old会进行一次全局GC(Full GC)。由于Serial Old的介入，会造成较大的停顿时间。

## 相关概念
#### 并行和并发 
- 并行（Paralle）： 指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态
- 并发（Concurrent）： 指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续进行，而垃圾收集线程运行在另一个CPU上

#### 吞吐量（Throughput）
吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即

吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。

假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

#### Minor GC和Full GC
- 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快
- 老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。 Major GC的速度一般会比Minor GC慢10倍以上。

至于Major GC和Full GC的区别是什么？具体还见[R大的解释](https://www.zhihu.com/question/41922036/answer/93079526)

## 新生代垃圾收集器
#### Serial Garbage Collector
**算法**： 复制算法

**内存区域**： 新生代

**执行方式**： 单线程、串行

**执行过程**：

1. 当新生代内存不够用时，暂停全部用户程序
2. 开启一条GC线程使用复制算法对垃圾进行回收，这一过程中可能会有一些对象提升到老年代

**特点**： 由于单线程运行，且整个GC阶段都要暂停用户程序，因此整个GC的停顿时间较长

**适用场景**： 平时的开发与调试程序，以及桌面应用交互程序

**开启参数**： -XX:+UseSerialGC(client模式默认值)

![](https://pic.yupoo.com/crowhawk/6b90388c/6c281cf0.png)

-----------

#### ParNew Garbage Collector
**算法**：复制算法

**内存区域**：新生代

**执行方式**： 多线程、并行

**执行过程**：

1. 当新生代内存不够用时，暂停全部用户程序
2. 开启若干条GC线程使用复制算法对垃圾进行回收，这一过程中可能会有一些对象提升到老年代

**特点**： 

1. 采用多线程并行运行，因此会对系统的内核处理器数目比较敏感，至少需要多于一个的处理器，有几个处理器就会开几个线程（不过线程数是可以使用参数-XX:ParallelGCThreads=<N>控制的），因此只适合于多核多处理器的系统。
2. 尽管整个GC阶段还是要暂停用户程序，但多线程并行处理并不会造成太长的停顿时间。因此就吞吐量来说，ParNew要大于serial，在处理器越多的时候，效果越明显。但是这并非绝对，对于单个处理器来说，由于并行执行的开销（比如同步），ParNew的性能将会低于serial搜集器。不仅是单个处理器的时候，如果在容量较小的堆上，甚至在两个处理器的情况下，ParNew的性能都并非一定可以高过serial。

**适用场景**： 在中到大型的堆上，且系统处理器至少多于一个的情况

**开启参数**： -XX:+UseParNewGC

![](https://pic.yupoo.com/crowhawk/605f57b5/75122b84.png)

-----------

#### Parallel Scavenge Garbage Collector
**算法**：采用复制算法

**内存区域**：针对新生代设计

**执行方式**：多线程、并行

**执行过程**：当新生代内存不够用时，先暂停全部用户程序，然后开启若干条GC线程使用复制算法并行进行垃圾回收，这一过程中可能会有一些对象提升到年老代

**特点**：

1. 可设置更精确的控制GC停顿时间以及吞吐量
2. 使用-XX:MaxGCPauseMillis=<N>来控制最大的停顿时间
3. 使用-XX:GCTimeRatio=<N>来控制吞吐量
4. 使用-XX:UseAdaptiveSizePolicy打开内存区域大小自适应策略

**适用场景**：在中到大型的堆上，且系统处理器至少多于一个的情况

**开启参数**：-XX:+UseParallelGC(server模式下默认的新生代搜集器)

![](https://segmentfault.com/img/remote/1460000004846443)

-----------

## 老年代垃圾收集器
#### Serial Old Garbage Collector
**算法**：采用标记-整理算法

**内存区域**：针对老年代设计

**执行方式**：单线程、串行

**执行过程**：由于单线程运行，且整个GC阶段都要暂停用户程序，因此整个GC的停顿时间较长

**特点**：

1. 在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用
2. 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用

**适用场景**：平时的开发与调试程序，以及桌面应用交互程序

**开启参数**：-XX:+UseSerialOldGC

-----------

##### Parallel Old Garbage Collector
**算法**：采用标记-整理算法

**内存区域**：针对老年代设计

**执行方式**：多线程、并行

**执行过程**：与Parallel GC类型

**特点**：

1. 除了serial old以外唯一一个可以与parallel scavenge搭配工作的年老代搜集器
2. 在JDK6以后，它也是在开启parallel scavenge之后默认的年老代搜集器

**适用场景**：后台运算而不需要太多交互的任务

**开启参数**：-XX:-UseParallelOldGC

-----------

#### Concurrent Mark Sweep Garbage Collector
**算法**：采用标记-清除算法

**内存区域**：针对老年代设计

**执行方式**：多线程、并发

**执行过程**：

1. 初始标记： 需要暂停应用程序，快速标记存活对象
2. 并发标记： 恢复应用程序，并发跟踪GC Roots
3. 重新标记： 需要暂停应用程序，重新标记跟踪遗漏的对象
4. 并发清除： 恢复应用程序，并发清除未标记的垃圾对象

**特点**：
	
	优点：
		1. 并发收集
		2. 低停顿
	缺点：
		1. 对CPU资源非常敏感。CPU个数少于4个时，CMS对于用户程序影响可能变得很大
		2. 无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC（Serial Old GC）的产生

**适用场景**：集中在互联网站点或B/S系统服务端上的Java应用

**开启参数**：-XX:+UseConcMarkSweepGC

![](https://pic.yupoo.com/crowhawk/fffcf9a2/f60599b2.png)

#### Garbage-First Garbage Collector
**算法**：采用标记-整理+复制算法

**内存区域**：新生代、老年代

**执行方式**：多线程、并发

**执行过程**：

如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：

1. 初始标记（Initial Marking） 

	仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。
2. 并发标记（Concurrent Marking） 

	从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。
3. 最终标记（Final Marking） 

	为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。
4. 筛选回收（Live Data Counting and Evacuation） 

	首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。


**特点**：

- 并行与并发 
	
	G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。
- 分代收集 

	与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同方式去处理新创建的对象和已存活一段时间、熬过多次GC的旧对象来获取更好的收集效果。
- 空间整合 

	G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。这意味着G1运行期间不会产生内存空间碎片，收集后能提供规整的可用内存。此特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
- 可预测的停顿 

	这是G1相对CMS的一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了降低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

**适用场景**：面向服务端应用，将来替换CMS

**开启参数**：-XX:+UseG1GC

![](https://pic.yupoo.com/crowhawk/53b7a589/0bce1667.png)


## 总结
|收集器		|串行、并行or并发	|新生代/老年代	|算法	|目标	|适用场景	|
|---		|---				|	---			|---	|---	|---		|
|Serial	|	串行|	新生代	|复制算法	|响应速度优先|单CPU环境下的Client模式|
|Serial Old|	串行	|老年代|	标记-整理|	响应速度优先|单CPU环境下的Client模式、CMS的后备预案|
|ParNew	|并行|	新生代|	复制算法|	响应速度优先|多CPU环境时在Server模式下与CMS配合|
|Parallel Scavenge|	并行	|新生代	|复制算法|吞吐量优先|在后台运算而不需要太多交互的任务
|Parallel Old	|并行	|老年代|	标记-整理|	吞吐量优先|在后台运算而不需要太多交互的任务
|CMS|	并发|	老年代	|标记-清除|	响应速度优先|集中在互联网站或B/S系统服务端上的Java应用
|G1|	并发|	both	|标记-整理+复制算法	|响应速度优先|面向服务端应用，将来替换CMS

## 参考资料
- [JVM内存管理------垃圾搜集器精解（让你在垃圾搜集器的世界里耍的游刃有余）](http://www.cnblogs.com/zuoxiaolong/p/jvm8.html)
- [深入理解JVM(3)——7种垃圾收集器](https://crowhawk.github.io/2017/08/15/jvm_3/)
- [《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明](https://book.douban.com/subject/24722612/)
- [高级语言虚拟机](http://hllvm.group.iteye.com/)

